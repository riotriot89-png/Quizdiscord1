import discord
from discord.ext import commands
import random
from PIL import Image, ImageDraw
import io
import aiohttp
import asyncio
from quiz_questions import quiz_questions
import json, os

from flask import Flask
import threading

app = Flask('')

@app.route('/')
def home():
    return "Bot is awake!"

def run():
    app.run(host='0.0.0.0', port=8080)

def keep_alive():
    t = threading.Thread(target=run)
    t.start()


SCORE_FILE = "scores.json"
INVENTORY_FILE = "inventory.json"

def load_scores():
    if os.path.exists(SCORE_FILE):
        with open(SCORE_FILE, "r", encoding="utf-8") as f:
            return json.load(f)
    return {}

def save_scores():
    with open(SCORE_FILE, "w", encoding="utf-8") as f:
        json.dump(player_scores, f, ensure_ascii=False, indent=4)

def load_inventory():
    if os.path.exists(INVENTORY_FILE):
        with open(INVENTORY_FILE, "r", encoding="utf-8") as f:
            return json.load(f)
    return {}

def save_inventory():
    with open(INVENTORY_FILE, "w", encoding="utf-8") as f:
        json.dump(player_inventory, f, ensure_ascii=False, indent=4)


# ======================
# Kh·ªüi t·∫°o bot
# ======================
intents = discord.Intents.default()
intents.message_content = True
bot = commands.Bot(command_prefix="bz", intents=intents)

# ======================
# L∆∞u ƒëi·ªÉm ng∆∞·ªùi ch∆°i
# ======================
player_scores = load_scores()
player_inventory = load_inventory()

# ======================
# Danh s√°ch khung
# ======================
FRAMES = {
    0: {"name": "Khung M·∫∑c ƒê·ªãnh", "price": 0, "file": "frame.png", "emoji": "üñºÔ∏è"},
    1: {"name": "Khung ƒê·ªìng", "price": 10, "file": "frame1.png", "emoji": "ü•â"},
    2: {"name": "Khung B·∫°c", "price": 20, "file": "frame2.png", "emoji": "ü•à"},
    3: {"name": "Khung V√†ng", "price": 50, "file": "frame3.png", "emoji": "ü•á"},
    4: {"name": "Khung Kim C∆∞∆°ng", "price": 100, "file": "frame4.png", "emoji": "üíé"}
}

# ======================
# Danh s√°ch c√¢u h·ªèi ƒë√£ h·ªèi
# ======================
asked_questions = set()
is_quiz_running = False
quiz_lock = asyncio.Lock()
no_answer_streak = 0


# ======================
# H√†m t·∫°o avatar h√¨nh tr√≤n
# ======================
def make_circle_avatar(avatar_img, size=(128,128)):
    avatar_img = avatar_img.resize(size).convert("RGBA")
    mask = Image.new("L", size, 0)
    draw = ImageDraw.Draw(mask)
    draw.ellipse((0, 0, size[0], size[1]), fill=255)
    avatar_img.putalpha(mask)
    return avatar_img

# ======================
# H√†m gh√©p avatar d∆∞·ªõi khung PNG
# ======================
def merge_avatar_with_frame_on_top(
    avatar_bytes,
    frame_path='frame.png',
    avatar_size=(158,158),
    final_size=(256,256),
    y_offset=-10
):
    avatar_img = Image.open(io.BytesIO(avatar_bytes))
    avatar_img = make_circle_avatar(avatar_img, size=avatar_size)
    
    # Ki·ªÉm tra file khung c√≥ t·ªìn t·∫°i kh√¥ng, n·∫øu kh√¥ng d√πng frame.png
    if not os.path.exists(frame_path):
        frame_path = 'frame.png'
    
    frame = Image.open(frame_path).convert("RGBA").resize(final_size)

    pos_x = (final_size[0] - avatar_size[0]) // 2
    pos_y = (final_size[1] - avatar_size[1]) // 2 + y_offset

    canvas = Image.new("RGBA", final_size, (0,0,0,0))
    canvas.paste(avatar_img, (pos_x, pos_y), avatar_img)
    canvas.paste(frame, (0,0), frame)

    output_bytes = io.BytesIO()
    canvas.save(output_bytes, format="PNG")
    output_bytes.seek(0)
    return output_bytes

def get_user_frame(user_id):
    """L·∫•y khung ƒëang trang b·ªã c·ªßa ng∆∞·ªùi ch∆°i"""
    user_id = str(user_id)
    if user_id not in player_inventory:
        return "frame.png"
    
    equipped = player_inventory[user_id].get("equipped", 0)
    return FRAMES[equipped]["file"]

# ======================
# Giao di·ªán tr·∫£ l·ªùi (button)
# ======================
import time

class QuizView(discord.ui.View):
    def __init__(self, quiz, ctx, question_message):
        super().__init__(timeout=20)
        self.quiz = quiz
        self.correct_answer = quiz["answer"]
        self.ctx = ctx
        self.winner = None
        self.question_message = question_message
        self.answered_users = {}
        self.start_time = time.time()

    async def on_timeout(self):
        """Khi h·∫øt th·ªùi gian"""
        for child in self.children:
            child.disabled = True
        await self.question_message.edit(view=self)
        await self.show_results(timeout=True)

    @discord.ui.button(label="A", style=discord.ButtonStyle.primary)
    async def a(self, interaction: discord.Interaction, button: discord.ui.Button):
        await self.check_answer(interaction, "A")

    @discord.ui.button(label="B", style=discord.ButtonStyle.primary)
    async def b(self, interaction: discord.Interaction, button: discord.ui.Button):
        await self.check_answer(interaction, "B")

    @discord.ui.button(label="C", style=discord.ButtonStyle.primary)
    async def c(self, interaction: discord.Interaction, button: discord.ui.Button):
        await self.check_answer(interaction, "C")

    @discord.ui.button(label="D", style=discord.ButtonStyle.primary)
    async def d(self, interaction: discord.Interaction, button: discord.ui.Button):
        await self.check_answer(interaction, "D")

    async def check_answer(self, interaction, answer):
        global player_scores

        if interaction.user.id in self.answered_users:
            await interaction.response.send_message("‚ö†Ô∏è B·∫°n ƒë√£ tr·∫£ l·ªùi r·ªìi, kh√¥ng th·ªÉ ch·ªçn l·∫°i!", ephemeral=True)
            return

        elapsed = round(time.time() - self.start_time, 2)
        self.answered_users[interaction.user.id] = {
            "user": interaction.user,
            "answer": answer,
            "time": elapsed
        }

        if self.winner:
            await interaction.response.send_message("‚ùó ƒê√£ c√≥ ng∆∞·ªùi tr·∫£ l·ªùi ƒë√∫ng r·ªìi!", ephemeral=True)
            return

        if answer == self.correct_answer:
            self.winner = interaction.user
            player_scores[str(self.winner.id)] = player_scores.get(str(self.winner.id), 0) + 1
            save_scores()
            score = player_scores[str(self.winner.id)]

            # T·∫£i avatar
            async with aiohttp.ClientSession() as session:
                async with session.get(self.winner.display_avatar.url) as resp:
                    avatar_bytes = await resp.read()

            # L·∫•y khung ƒëang trang b·ªã
            frame_path = get_user_frame(self.winner.id)

            # Gh√©p avatar v·ªõi khung (nh·ªè h∆°n ƒë·ªÉ l√†m thumbnail)
            png_bytes = merge_avatar_with_frame_on_top(
                avatar_bytes,
                frame_path=frame_path,
                avatar_size=(110,110),
                final_size=(150,150),
                y_offset=-5
            )
            file = discord.File(fp=png_bytes, filename="winner.png")

            for child in self.children:
                child.disabled = True
            await self.question_message.edit(view=self)

            await self.show_results(timeout=False, file=file, winner_score=score)

            self.stop()
        else:
            await interaction.response.send_message("‚ùå Sai r·ªìi, b·∫°n kh√¥ng th·ªÉ ch·ªçn l·∫°i!", ephemeral=True)

    async def show_results(self, timeout=False, file=None, winner_score=None):
        """Hi·ªÉn th·ªã k·∫øt qu·∫£ b·∫±ng embed"""
        correct_list = []
        wrong_list = []

        for data in self.answered_users.values():
            user = data["user"]
            ans = data["answer"]
            t = data["time"]

            if ans == self.correct_answer:
                correct_list.append(f"‚úÖ {user.mention} ‚Äî {ans} ({t}s)")
            else:
                wrong_list.append(f"‚ùå {user.mention} ‚Äî {ans} ({t}s)")

        if not correct_list:
            correct_list = ["(Kh√¥ng ai ch·ªçn ƒë√∫ng)"]
        if not wrong_list:
            wrong_list = ["(Kh√¥ng ai ch·ªçn sai)"]

        embed = discord.Embed(
            title="üìã K·∫øt qu·∫£ c√¢u h·ªèi",
            color=discord.Color.blurple()
        )
        embed.add_field(name="----- TR·∫¢ L·ªúI ƒê√öNG ‚úÖ -----", value="\n".join(correct_list), inline=False)
        embed.add_field(name="----- TR·∫¢ L·ªúI SAI ‚ùå -----", value="\n".join(wrong_list), inline=False)
        embed.add_field(name="üïì Th·ªùi gian t·ªëi ƒëa", value="20 gi√¢y", inline=True)
        
        options = self.quiz["options"]
        full_answer = next(
            (opt for opt in options if opt.startswith(self.correct_answer + ")")),
            self.correct_answer
        )

        embed.add_field(
            name="----- üìñ ƒê√ÅP √ÅN CH√çNH X√ÅC -----",
            value=full_answer,
            inline=False
        )

        embed.add_field(name="\u200b", value="\n\u200b", inline=False)
        embed.set_footer(text="Crate: üå∏ Boizzzz üó°")

        if self.winner and not timeout:
            embed.description = f"üéâ **{self.winner.mention}** ƒë√£ tr·∫£ l·ªùi ƒë√∫ng v√† nhanh nh·∫•t!"
            embed.color = discord.Color.green()
            embed.set_thumbnail(url="attachment://winner.png")  # D√πng thumbnail thay v√¨ image
            embed.add_field(name="üèÖ ƒêi·ªÉm hi·ªán t·∫°i", value=f"{winner_score} ƒëi·ªÉm", inline=False)
            await self.ctx.send(embed=embed, file=file)
        else:
            embed.description = "‚è∞ H·∫øt th·ªùi gian ho·∫∑c kh√¥ng ai tr·∫£ l·ªùi ƒë√∫ng!"
            await self.ctx.send(embed=embed)

# ======================
# L·ªánh quiz
# ======================
@bot.command()
async def quiz(ctx):
    global asked_questions, is_quiz_running, no_answer_streak

    async with quiz_lock:
        if is_quiz_running:
            await ctx.send("‚ö†Ô∏è ƒêang c√≥ c√¢u h·ªèi di·ªÖn ra r·ªìi! Vui l√≤ng ƒë·ª£i c√¢u h·ªèi n√†y k·∫øt th√∫c.")
            return

        is_quiz_running = True
        no_answer_streak = 0

    while True:
        remaining_questions = [q for q in quiz_questions if q["question"] not in asked_questions]

        if not remaining_questions:
            await ctx.send("üéØ H·∫øt c√¢u h·ªèi r·ªìi! H√£y reset bot ho·∫∑c th√™m c√¢u h·ªèi m·ªõi nh√©.")
            is_quiz_running = False
            break

        question_data = random.choice(remaining_questions)
        asked_questions.add(question_data["question"])

        embed = discord.Embed(
            title="üß† C√¢u h·ªèi ki·∫øn th·ª©c",
            description=question_data["question"],
            color=random.randint(0, 0xFFFFFF)
        )
                        embed.add_field(name="C√°c l·ª±a ch·ªçn", value="\n".join(question_data["options"]), inline=False)
        embed.set_footer(text="‚è∞ B·∫°n c√≥ 20 gi√¢y ƒë·ªÉ tr·∫£ l·ªùi!")

        msg = await ctx.send(embed=embed)
        view = QuizView(question_data, ctx, msg)
        await msg.edit(view=view)

        await view.wait()

        if not view.answered_users:
            no_answer_streak += 1
        else:
            no_answer_streak = 0

        if no_answer_streak >= 4:
            await ctx.send("üö´ Kh√¥ng ai tr·∫£ l·ªùi trong 4 c√¢u li√™n ti·∫øp ‚Äî k·∫øt th√∫c tr√≤ ch∆°i!")
            break

        await asyncio.sleep(1)

    is_quiz_running = False

# ======================
# L·ªánh xem b·∫£ng ƒëi·ªÉm
# ======================
@bot.command()
async def score(ctx):
    if not player_scores:
        await ctx.send("üìä Ch∆∞a c√≥ ai c√≥ ƒëi·ªÉm c·∫£.")
        return

    sorted_scores = sorted(player_scores.items(), key=lambda x: x[1], reverse=True)
    total_players = len(sorted_scores)
    mid = max(1, total_players // 2)

    smart_players = sorted_scores[:mid]
    dumb_players = sorted_scores[mid:]

    smart_list = ""
    for i, (user_id, points) in enumerate(smart_players, start=1):
        user = await bot.fetch_user(int(user_id))
        smart_list += f"{i}. üß† **{user.name}** ‚Äî {points} ƒëi·ªÉm\n"

    dumb_list = ""
    if dumb_players:
        for i, (user_id, points) in enumerate(dumb_players, start=mid + 1):
            user = await bot.fetch_user(int(user_id))
            dumb_list += f"{i}. üòÖ **{user.name}** ‚Äî {points} ƒëi·ªÉm\n"
    else:
        dumb_list = "(Kh√¥ng c√≥ ai ·ªü nh√≥m n√†y üéâ)"

    embed = discord.Embed(
        title="üèÜ X·∫øp ƒë·ªô TH√îNG MINH n√†o ",
        color=discord.Color.gold()
    )
    embed.add_field(name="üß† Nh·ªØng ng∆∞·ªùi Th√¥ng Minh", value=smart_list, inline=False)
    embed.add_field(name="üí© Nh·ªØng ng∆∞·ªùi NG·ªú U", value=dumb_list, inline=False)
    embed.set_footer(text="Crate : üå∏ Boizzzz üó°")

    await ctx.send(embed=embed)

# ======================
# L·ªánh shop
# ======================
@bot.command()
async def shop(ctx):
    embed = discord.Embed(
        title="üõí SHOP KHUNG AVATAR",
        description="D√πng ƒëi·ªÉm c·ªßa b·∫°n ƒë·ªÉ mua khung ƒë·∫πp h∆°n!",
        color=discord.Color.blue()
    )
    
    for frame_id, frame_data in FRAMES.items():
        status = "üéÅ MI·ªÑN PH√ç" if frame_data["price"] == 0 else f"üí∞ {frame_data['price']} ƒëi·ªÉm"
        embed.add_field(
            name=f"{frame_data['emoji']} {frame_data['name']} (ID: {frame_id})",
            value=f"Gi√°: {status}",
            inline=False
        )
    
    user_points = player_scores.get(str(ctx.author.id), 0)
    embed.set_footer(text=f"üíµ ƒêi·ªÉm c·ªßa b·∫°n: {user_points} | D√πng !buy <ID> ƒë·ªÉ mua")
    
    await ctx.send(embed=embed)

# ======================
# L·ªánh mua khung
# ======================
@bot.command()
async def buy(ctx, frame_id: int):
    user_id = str(ctx.author.id)
    
    # Ki·ªÉm tra khung c√≥ t·ªìn t·∫°i kh√¥ng
    if frame_id not in FRAMES:
        await ctx.send("‚ùå ID khung kh√¥ng h·ª£p l·ªá! D√πng `bzshop` ƒë·ªÉ xem danh s√°ch.")
        return
    
    frame = FRAMES[frame_id]
    
    # Kh·ªüi t·∫°o inventory n·∫øu ch∆∞a c√≥
    if user_id not in player_inventory:
        player_inventory[user_id] = {"owned": [0], "equipped": 0}
    
    # Ki·ªÉm tra ƒë√£ s·ªü h·ªØu ch∆∞a
    if frame_id in player_inventory[user_id]["owned"]:
        await ctx.send(f"‚ö†Ô∏è B·∫°n ƒë√£ s·ªü h·ªØu **{frame['name']}** r·ªìi!")
        return
    
    # Ki·ªÉm tra ƒë·ªß ƒëi·ªÉm kh√¥ng
    user_points = player_scores.get(user_id, 0)
    if user_points < frame["price"]:
        await ctx.send(f"‚ùå Kh√¥ng ƒë·ªß ƒëi·ªÉm! B·∫°n c·∫ßn **{frame['price']}** ƒëi·ªÉm nh∆∞ng ch·ªâ c√≥ **{user_points}** ƒëi·ªÉm.")
        return
    
    # Tr·ª´ ƒëi·ªÉm v√† th√™m khung
    player_scores[user_id] = user_points - frame["price"]
    player_inventory[user_id]["owned"].append(frame_id)
    
    save_scores()
    save_inventory()
    
    embed = discord.Embed(
        title="‚úÖ MUA TH√ÄNH C√îNG!",
        description=f"B·∫°n ƒë√£ mua **{frame['emoji']} {frame['name']}**!",
        color=discord.Color.green()
    )
    embed.add_field(name="üí∞ Gi√°", value=f"{frame['price']} ƒëi·ªÉm", inline=True)
    embed.add_field(name="üíµ ƒêi·ªÉm c√≤n l·∫°i", value=f"{player_scores[user_id]} ƒëi·ªÉm", inline=True)
    embed.set_footer(text="D√πng !equip <ID> ƒë·ªÉ trang b·ªã khung n√†y")
    
    await ctx.send(embed=embed)

# ======================
# L·ªánh trang b·ªã khung
# ======================
@bot.command()
async def equip(ctx, frame_id: int):
    user_id = str(ctx.author.id)
    
    # Ki·ªÉm tra khung c√≥ t·ªìn t·∫°i kh√¥ng
    if frame_id not in FRAMES:
        await ctx.send("‚ùå ID khung kh√¥ng h·ª£p l·ªá!")
        return
    
    # Ki·ªÉm tra ƒë√£ s·ªü h·ªØu ch∆∞a
    if user_id not in player_inventory or frame_id not in player_inventory[user_id]["owned"]:
        await ctx.send(f"‚ùå B·∫°n ch∆∞a s·ªü h·ªØu khung n√†y! D√πng `bzbuy {frame_id}` ƒë·ªÉ mua.")
        return
    
    # Trang b·ªã khung
    player_inventory[user_id]["equipped"] = frame_id
    save_inventory()
    
    frame = FRAMES[frame_id]
    embed = discord.Embed(
        title="‚úÖ TRANG B·ªä TH√ÄNH C√îNG!",
        description=f"B·∫°n ƒë√£ trang b·ªã **{frame['emoji']} {frame['name']}**!",
        color=discord.Color.green()
    )
    embed.set_footer(text="Khung n√†y s·∫Ω hi·ªÉn th·ªã khi b·∫°n tr·∫£ l·ªùi ƒë√∫ng c√¢u h·ªèi!")
    
    await ctx.send(embed=embed)

# ======================
# L·ªánh xem inventory
# ======================
@bot.command(aliases=["inv"])
async def inventory(ctx):
    user_id = str(ctx.author.id)
    
    if user_id not in player_inventory or not player_inventory[user_id]["owned"]:
        await ctx.send("üì¶ B·∫°n ch∆∞a c√≥ khung n√†o! D√πng `bzshop` ƒë·ªÉ xem v√† mua khung.")
        return
    
    owned = player_inventory[user_id]["owned"]
    equipped = player_inventory[user_id]["equipped"]
    
    embed = discord.Embed(
        title="üéí T·ª¶ ƒê·ªí C·ª¶A B·∫†N",
        description="C√°c khung b·∫°n ƒëang s·ªü h·ªØu:",
        color=discord.Color.purple()
    )
    
    for frame_id in owned:
        frame = FRAMES[frame_id]
        status = "‚úÖ ƒêANG TRANG B·ªä" if frame_id == equipped else "‚ö™ Ch∆∞a trang b·ªã"
        embed.add_field(
            name=f"{frame['emoji']} {frame['name']} (ID: {frame_id})",
            value=status,
            inline=False
        )
    
    embed.set_footer(text="D√πng !equip <ID> ƒë·ªÉ thay ƒë·ªïi khung")
    
    await ctx.send(embed=embed)

import os
keep_alive()

# ======================
# L·ªánh help t√πy ch·ªânh
# ======================
bot.remove_command('help')  # X√≥a l·ªánh help m·∫∑c ƒë·ªãnh

@bot.command()
async def help(ctx):
    """Hi·ªÉn th·ªã danh s√°ch l·ªánh"""
    embed = discord.Embed(
        title="üìö H∆Ø·ªöNG D·∫™N S·ª¨ D·ª§NG BOT",
        description="Danh s√°ch c√°c l·ªánh b·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng:",
        color=discord.Color.blue()
    )
    
    # Game Commands
    embed.add_field(
        name="üéÆ L·ªÜNH CH∆†I GAME",
        value=(
            "`bzquiz` - B·∫Øt ƒë·∫ßu tr√≤ ch∆°i c√¢u h·ªèi\n"
            "`bzscore` - Xem b·∫£ng x·∫øp h·∫°ng ƒëi·ªÉm\n"
        ),
        inline=False
    )
    
    # Shop Commands
    embed.add_field(
        name="üõí L·ªÜNH SHOP KHUNG",
        value=(
            "`bzshop` - Xem danh s√°ch khung c√≥ th·ªÉ mua\n"
            "`bzbuy <ID>` - Mua khung (VD: `bzbuy 1`)\n"
            "`bzequip <ID>` - Trang b·ªã khung ƒë√£ mua\n"
            "`bzinventory` ho·∫∑c `bzinv` - Xem khung ƒë√£ s·ªü h·ªØu\n"
        ),
        inline=False
    )
    
    # Info
    embed.add_field(
        name="üí° TH√îNG TIN",
        value=(
            "‚Ä¢ Tr·∫£ l·ªùi ƒë√∫ng c√¢u h·ªèi ƒë·ªÉ nh·∫≠n **1 ƒëi·ªÉm**\n"
            "‚Ä¢ D√πng ƒëi·ªÉm ƒë·ªÉ mua khung ƒë·∫πp trong shop\n"
            "‚Ä¢ Khung s·∫Ω hi·ªÉn th·ªã khi b·∫°n tr·∫£ l·ªùi ƒë√∫ng\n"
        ),
        inline=False
    )
    
    embed.set_footer(text="Crate: üå∏ Boizzzz üó° | Ch√∫c b·∫°n ch∆°i vui v·∫ª!")
    embed.set_thumbnail(url=bot.user.avatar.url if bot.user.avatar else None)
    
    await ctx.send(embed=embed)

import os
keep_alive()
bot.run(os.getenv("DISCORD_TOKEN"))
#add keep_alive for Render

















